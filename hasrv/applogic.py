#!/bin/env python3
######################################################################
#  2022/09/14 Doug Leece  inital test build
#
# The applicaton form will allow pressing of 4 buttons, 
# the challenge goal is to adjust a config file or edit a code fuction to 
# reflect the correct settings after you sniff the traffic generated by the physical device
# 
#####################################################################


import flask,logging
from flask import Blueprint, render_template, redirect, url_for,flash, request,current_app
from flask import Blueprint, current_app
from os import environ, path
import sys, signal, time, argparse
import RPi.GPIO as GPIO

# get the database connection
from .models import hasrvdb, hasrvstate

# Flask Blueprint setup
applogic = Blueprint('applogic', __name__)

# PI GPIO stuff,  could be moved to a module if need be.
# requires rpi_rf https://pypi.org/project/rpi-rf/
GPIO.setmode(GPIO.BCM)

from rpi_rf import RFDevice
# Create new device with default settings, change the GPIO pin if different than the many inet tutorials 
rfdev = RFDevice(17)

# Great artists steal, mediocre ones do too. Borrowing major chunks of the send script sample from rpi_rf
# RF transmission function, requires RF device object and the correct code data
def sendinstruction(thisdev, thiscode,thispulse,thisproto):
    thispulse=int(thispulse)
    thisproto=int(thisproto)
    txtest=thisdev.enable_tx()
    if txtest:
        # presuming OOK code length of 24,  if proto 6 I guess you need 32 -- stuff to look into
        # Adjust for high noise environments
        #thisdev.tx_repeat=int(40)
        thisdev.tx_code(thiscode,thisproto,thispulse,24)
        #Reset GPIO pin as transmit mode or you crash it.
        thisdev.disable_tx()
        return True
    else:
        return False

def sendiochange(iopoint,txdatalist):
    thisio="io" + str(iopoint)  
    iorecord = getcuriostat(hasrvstate,thisio)
    curstat = iorecord.iostate
    txstat = sendinstruction(rfdev,txdatalist[0],txdatalist[1],txdatalist[2])
    #print("txstat {}".format(str(txstat)))
    #print(curstat)
    if (txstat and curstat == 'off'):
        print("update DB entry for {}, set to on".format(thisio))
        iorecord.iostate='on'
        curstat='on'
        hasrvdb.session.commit()
        return True
    elif (txstat and curstat == 'on'):
        print("update DB entry for {}, set to off".format(thisio))
        iorecord.iostate='off'
        curstat='off'
        hasrvdb.session.commit()
        return True
    else:
        print("potential transmission failure, investigate")
        return False


# Pull record based on io being updated
def getcuriostat(thisdb,testio):
    dbrow=thisdb.query.filter_by(ioname = testio).first()
    return dbrow

def getalliostat(thisdb):
    allio=thisdb.query.all()
    alliolist=[]
    for row in allio:
        alliolist.append('{}: {} -> {}'.format(row.ioname,row.iodesc,row.iostate))
    return alliolist

def gettxcodedata(iotarget):
    txlist=[]
    if iotarget == 0:
        txlist=[12345,100,12]
    elif iotarget == 1:
        txlist=[67890,200,6]
    elif iotarget == 2:
        txlist=[234765,300,3]
    else:
        txlist=[987654,400,1]
    return txlist


##############################################################################################
# HTTP routes and primary page functions

@applogic.route('/')
def index():
    # retrieve database content for presentation:
    thisiolist=getalliostat(hasrvstate)
    return render_template('hasmainv2.html',iodata=thisiolist, rows=len(thisiolist))

# Main IO page, retrieve IO value passed in checkbox
@applogic.route('/io', methods = ["POST","GET"])
def sendiochange_rb():
    if request.method == "POST":
        iorbvals = request.form.getlist('hadev')
        if isinstance(iorbvals,list) and  int(iorbvals[0]) in [0,1,2,3]:
            ioselect= int(iorbvals[0])
            txdata = gettxcodedata(ioselect)
            txstatus=sendiochange(ioselect,txdata)
        # retrieve database content for presentation:
        thisiolist=getalliostat(hasrvstate)
        if txstatus:
            return render_template('hasmainv2.html',iodata=thisiolist, rows=len(thisiolist))
        else:
            # add in some alert message inducating something went wrong
            return render_template('hasmainv2.html',iodata=thisiolist, rows=len(thisiolist))
    
    if request.method == "GET":
        thisiolist=getalliostat(hasrvstate)
        return render_template('hasmainv2.html',iodata=thisiolist, rows=len(thisiolist))

# reset the IO if it gets out of sync
@applogic.route('/reset', methods = ["GET"])
def resetdb():
    resetio=request.args.get('io')
    if resetio == None:
        thisiolist=getalliostat(hasrvstate)
        return render_template('hasmainv2.html',iodata=thisiolist, rows=len(thisiolist))
    else:
        try:
        # reset to off rather than toggle feature. Only really needed when things get out of sync
            if int(resetio) in [0,1,2,3]:
                thisio="io" + str(resetio)
                iorecord = getcuriostat(hasrvstate,thisio)
                iorecord.iostate='off'
                hasrvdb.session.commit()
        
            thisiolist=getalliostat(hasrvstate)
            return render_template('hasmainv2.html',iodata=thisiolist, rows=len(thisiolist))
        except ValueError:
        # retrieve database content for presentation:
            thisiolist=getalliostat(hasrvstate)
            return render_template('hasmainv2.html',iodata=thisiolist, rows=len(thisiolist))